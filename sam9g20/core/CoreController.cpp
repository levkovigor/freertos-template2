#include "CoreController.h"

#include <fsfw/timemanager/Stopwatch.h>
#include <systemObjectList.h>

extern "C" {
#include <hal/Timing/Time.h>
#include <hal/Timing/RTT.h>
}

#include <utility/portwrapper.h>

uint32_t CoreController::counterOverflows = 0;
uint32_t CoreController::idleCounterOverflows = 0;

CoreController::CoreController(object_id_t objectId): ControllerBase(objectId,
        objects::NO_OBJECT), actionHelper(this, commandQueue), taskStatArray(0) {
#ifdef ISIS_OBC_G20
    Supervisor_start(nullptr, 0);
#endif
}

ReturnValue_t CoreController::handleCommandMessage(CommandMessage *message) {
    return actionHelper.handleActionMessage(message);
}

void CoreController::performControlOperation() {

    // First task: get supervisor state
#ifdef ISIS_OBC_G20
    int result = Supervisor_getHousekeeping(&supervisorHk, SUPERVISOR_INDEX);
    // should not happen.
    if(result != 0) {}
    supervisor_enable_status_t* temporaryEnable =
            &(supervisorHk.fields.enableStatus);
    if(temporaryEnable) {}
    Supervisor_calculateAdcValues(&supervisorHk, adcValues);
    // now store everything into a local pool. Also take action if any values
    // are out of order.
#endif

    /* Check for overflows of 32bit counter regularly (currently every day).
    the second counter will take 4-5 years to overflow which exceeds
    mission time. */
    uint32_t currentUptimeSeconds = RTT_GetTime();
    if(currentUptimeSeconds - lastCounterUpdateSeconds >= DAY_IN_SECONDS) {
    	update64bitCounter();
    	lastCounterUpdateSeconds = currentUptimeSeconds;
    }

    if(cpuStatsDumpRequested and systemStateTask->getSystemStateWasRead()) {
    	// now we can read, analyze, prepare and dump the CPU stats.
    	// table generated will be quite similar to the one generated by
    	// FreeRTOS but we use own IDLE and total uptime counters which
    	// do not overflow during mission time to calculate the CPU stats.
    	// we also trigger an event if any stack values are too close
    	// too overflowing, using a specified threshold.
    	cpuStatsDumpRequested = false;
    }
}

ReturnValue_t CoreController::checkModeCommand(Mode_t mode, Submode_t submode,
        uint32_t *msToReachTheMode) {
    return HasReturnvaluesIF::RETURN_OK;
}

MessageQueueId_t CoreController::getCommandQueue() const {
    return ControllerBase::getCommandQueue();
}

ReturnValue_t CoreController::executeAction(ActionId_t actionId,
        MessageQueueId_t commandedBy, const uint8_t *data, size_t size) {
	if(actionId == REQUEST_CPU_STATS_CHECK_STACK) {
		if(cpuStatsDumpRequested) {
			// that command is still pending.
			return HasReturnvaluesIF::RETURN_FAILED;
		}
		// perform necessary steps to generate CPU stats and dump them.
	    // do this in a low priority task which is unblocked for that purpose.
	    systemStateTask->readSystemState();
	}
    return HasReturnvaluesIF::RETURN_OK;
}

ReturnValue_t CoreController::initializeAfterTaskCreation() {
	setUpSystemStateTask();
    initializeIsisTimerDrivers();
    return HasReturnvaluesIF::RETURN_OK;
}

uint64_t CoreController::getTotalRunTimeCounter() {
	return static_cast<uint64_t>(counterOverflows) << 32 |
			vGetCurrentTimerCounterValue();
}

uint64_t CoreController::getTotalIdleRunTimeCounter() {
	return static_cast<uint64_t>(idleCounterOverflows) << 32 |
			ulTaskGetIdleRunTimeCounter();
}

void CoreController::update64bitCounter() {
    uint32_t currentCounter = vGetCurrentTimerCounterValue();
    uint32_t currentIdleCounter = ulTaskGetIdleRunTimeCounter();
    if(currentCounter < last32bitCounterValue) {
    	// overflow occured.
    	counterOverflows ++;
    }

    if(currentIdleCounter < last32bitIdleCounterValue) {
    	// overflow occured.
    	idleCounterOverflows ++;
    }

    last32bitCounterValue = currentCounter;
    last32bitIdleCounterValue = currentIdleCounter;
}

void CoreController::setUpSystemStateTask() {
    numberOfTasks = uxTaskGetNumberOfTasks();
    taskStatArray.reserve(numberOfTasks);
    taskStatArray.resize(numberOfTasks);
    systemStateTask = objectManager->
            get<SystemStateTask>(objects::SYSTEM_STATE_TASK);
    if(systemStateTask != nullptr) {
        systemStateTask->assignStatusWritePtr(taskStatArray.data(),
                numberOfTasks);
    }
    else {
        sif::error << "CoreController::performControlOperation:"
                "System state task invalid!" << std::endl;
    }
}

void CoreController::initializeIsisTimerDrivers() {
#ifdef ISIS_OBC_G20
	// Time will be set later, this just starts the synchronization task
	// with a frequence of 0.5 seconds.
	int retval = Time_start(NULL, RTC_RTT_SYNC_INTERVAL);
	if(retval >> 8 == 0xFF) {
		sif::error << "CoreController::initializeAfterTaskCreation:"
				"ISIS RTC start failure!" << std::endl;
	}
	retval = retval & 0xFF;
	if(retval == 1) {
		// RTT not ticking. Should not happen! Trigger event.
	}
	else if(retval == 2) {
		// Should not happen, we did not specify time..
		sif::error << "CoreController::initializeAfterTaskCreation: Config"
				<< " error!" << std::endl;
	}
	else if(retval == 3) {
		// Should not happen, the scheduler is already running
		sif::error << "CoreController::initializeAfterTaskCreation: Config"
				<< " error, FreeRTOS scheduler not running!" << std::endl;
	}
	Time_setUnixEpoch(0);
#else
    RTT_start();
#endif
}
