#-------------------------------------------------------------------------------
# Makefile  for SOURCE OBSW
#-------------------------------------------------------------------------------
#		User-modifiable options
#-------------------------------------------------------------------------------

BOARD = stm32
ROOT_PATH = $(BOARD)
OUTPUT_FOLDER = $(BOARD)

# General folder paths
FRAMEWORK_PATH = fsfw
MISSION_PATH = mission
CONFIG_PATH = $(ROOT_PATH)/fsfwconfig
TEST_PATH = test
UNITTEST_PATH = unittest

# Board specific paths
BOARD_TEST_PATH = $(ROOT_PATH)/boardtest
BSP_PATH = $(ROOT_PATH)/bsp
COMIF_PATH = $(ROOT_PATH)/comIF
TMTCBRIDGE_PATH = $(ROOT_PATH)/tmtcbridge

BASENAME = sourceobsw

OS_FSFW = freeRTOS
BINARY_NAME = $(BASENAME)-stm32h743zit6

# Output Directories
BUILDPATH = _bin
DEPENDPATH = _dep
OBJECTPATH = _obj
ifeq ($(MAKECMDGOALS), mission)
BUILD_FOLDER = mission
TARGET = Mission build
else 
BUILD_FOLDER = devel
TARGET = Debug build
debug: OPTIMIZATION_MESSAGE = Off
endif

DEPENDDIR = $(DEPENDPATH)/$(OUTPUT_FOLDER)/$(BUILD_FOLDER)
OBJDIR = $(OBJECTPATH)/$(OUTPUT_FOLDER)/$(BUILD_FOLDER)
BINDIR = $(BUILDPATH)/$(OUTPUT_FOLDER)/$(BUILD_FOLDER)

# Toolchain Settings
CROSS_COMPILE = arm-none-eabi-

ifdef WINDOWS
CC = $(CROSS_COMPILE)gcc.exe
CXX = $(CROSS_COMPILE)g++.exe
AS = $(CROSS_COMPILE)as.exe
# Additional Tools
SIZE = $(CROSS_COMPILE)size.exe
STRIP = $(CROSS_COMPILE)strip.exe
CP = $(CROSS_COMPILE)objcopy.exe
else
# C Compiler
CC = $(CROSS_COMPILE)gcc

# C++ compiler
CXX = $(CROSS_COMPILE)g++

#Assembler 
AS = $(CROSS_COMPILE)as
# Additional Tools
SIZE = $(CROSS_COMPILE)size
STRIP = $(CROSS_COMPILE)strip
CP = $(CROSS_COMPILE)objcopy
endif

HEXCOPY = $(CP) -O ihex
BINCOPY = $(CP) -O binary -S

# Default debug output
DEBUG_LEVEL = -g3

# Optimization level. -O0 for debugging, -Os for size. -O0 is default.
OPTIMIZATION = -O0

# files to be compiled, will be filled in by include makefiles
# := assignment is neccessary so we get all paths right
# https://www.gnu.org/software/make/manual/html_node/Flavors.html
CXXSRC := 
CSRC := 
ASRC := 
INCLUDES := 

# Main
# CXXSRC += $(ROOT_PATH)/main.cpp
# CXXSRC += $(ROOT_PATH)/init_mission.cpp

# Directories where $(directoryname).mk files should be included from

SUBDIRS := $(ROOT_PATH)/Middlewares/LwIP $(FRAMEWORK_PATH) $(ROOT_PATH)/Drivers $(BSP_PATH) \
           $(CONFIG_PATH) $(TEST_PATH) $(BOARD_TEST_PATH) $(COMIF_PATH) $(TMTCBRIDGE_PATH) \
           $(MISSION_PATH) $(ROOT_PATH)

SRC_PATH = $(ROOT_PATH)/Src
DRIVER_PATH = $(ROOT_PATH)/Drivers
MIDDLEWARES_PATH = $(ROOT_PATH)/Middlewares
FREERTOS_PATH = $(ROOT_PATH)/freertos
#------------------------------------------------------------------------------------------------------------------------------------------------
# C sources
C_SOURCES =  \
$(SRC_PATH)/freertos.c \
$(SRC_PATH)/stm32h7xx_it.c \
$(SRC_PATH)/stm32h7xx_hal_timebase_tim.c \
$(SRC_PATH)/system_stm32h7xx.c \
$(DRIVER_PATH)/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_cortex.c \
$(DRIVER_PATH)/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_tim.c \
$(DRIVER_PATH)/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_tim_ex.c \
$(DRIVER_PATH)/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_rcc.c \
$(DRIVER_PATH)/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_rcc_ex.c \
$(DRIVER_PATH)/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_flash.c \
$(DRIVER_PATH)/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_flash_ex.c \
$(DRIVER_PATH)/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_gpio.c \
$(DRIVER_PATH)/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_hsem.c \
$(DRIVER_PATH)/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_dma.c \
$(DRIVER_PATH)/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_dma_ex.c \
$(DRIVER_PATH)/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_mdma.c \
$(DRIVER_PATH)/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c \
$(DRIVER_PATH)/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr_ex.c \
$(DRIVER_PATH)/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal.c \
$(DRIVER_PATH)/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_i2c.c \
$(DRIVER_PATH)/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_i2c_ex.c \
$(DRIVER_PATH)/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_uart.c \
$(DRIVER_PATH)/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_eth.c \
$(DRIVER_PATH)/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_adc.c \

# ASM sources. Startup assembler in included by Bsp.mk for now
ASM_SOURCES = 

ASRC += $(ASM_SOURCES)

CSRC += $(C_SOURCES)

# AS includes
AS_INCLUDES =  \
-I$(ROOT_PATH)/Inc

C_INCLUDES =  \
-I$(ROOT_PATH)/Inc \
-I$(ROOT_PATH)/Drivers/STM32H7xx_HAL_Driver/Inc \
-I$(ROOT_PATH)/Drivers/STM32H7xx_HAL_Driver/Inc/Legacy \
-I$(ROOT_PATH)/Drivers/CMSIS/Device/ST/STM32H7xx/Include \
-I$(ROOT_PATH)/Drivers/CMSIS/Include \
-I$(ROOT_PATH)/Bsp/ \
-I$(ROOT_PATH)/Bsp/config \
-I$(ROOT_PATH)/Drivers/Components/Include \
-I$(ROOT_PATH)/Drivers/Components/Include/Common \
-I$(ROOT_PATH)/Middlewares/Includes/LwIP \
-I$(ROOT_PATH)/Middlewares/Includes



# This is a hack from http://make.mad-scientist.net/the-eval-function/
#
# The problem is, that included makefiles should be aware of their relative path
# but not need to guess or hardcode it. So we set $(CURRENTPATH) for them. If
# we do this globally and the included makefiles want to include other makefiles as
# well, they would overwrite $(CURRENTPATH), screwing the include after them.
#
# By using a for-loop with an eval'd macro, we can generate the code to include all
# sub-makefiles (with the correct $(CURRENTPATH) set) before actually evaluating
# (and by this possibly changing $(CURRENTPATH)) them.
#
# This works recursively, if an included makefile wants to include, it can safely set 
# $(SUBDIRS) (which has already been evaluated here) and do
# "$(foreach S,$(SUBDIRS),$(eval $(INCLUDE_FILE)))"
# $(SUBDIRS) must be relative to the project root, so to include subdir foo, set
# $(SUBDIRS) = $(CURRENTPATH)/foo.
define INCLUDE_FILE
CURRENTPATH := $S
include $(S)/$(notdir $S).mk
endef
$(foreach S,$(SUBDIRS),$(eval $(INCLUDE_FILE)))

INCLUDES += ./stm32

# ETL library include.
ETL_PATH = etl/include
INCLUDES += $(ETL_PATH)

I_INCLUDES = $(addprefix -I, $(INCLUDES))
#$(info $${I_INCLUDES} is [${I_INCLUDES}])

# See: https://stackoverflow.com/questions/6687630/how-to-remove-unused-c-c-symbols-with-gcc-and-ld
# Used to throw away unused code. Reduces code size significantly !
# -Wl,--gc-sections: needs to be passed to the linker to discard unused sections
ifdef KEEP_UNUSED_CODE
PROTOTYPE_OPTIMIZATION = 
UNUSED_CODE_REMOVAL = 
else
PROTOTYPE_OPTIMIZATION = -ffunction-sections -fdata-sections
UNUSED_CODE_REMOVAL = -Wl,--gc-sections
# Link time optimization
# See https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html for reference
# Link time is larger and size of object files can not be retrieved
# but resulting binary is smaller. Could be used in mission/deployment build
# Requires -ffunction-section in linker call
LINK_TIME_OPTIMIZATION =
OPTIMIZATION += $(PROTOTYPE_OPTIMIZATION) 
endif 

# cpu
CPU = -mcpu=cortex-m7

# fpu
FPU = -mfpu=fpv5-d16

# float-abi 
FLOAT-ABI = -mfloat-abi=hard

# mcu
MCU_FLAGS = $(CPU) -mthumb $(FPU) $(FLOAT-ABI)
# Newlib Nano
NEWLIB_NANO = -specs=nosys.specs -specs=nano.specs

# Flags

# Dependency Flags
# These flags tell the compiler to build dependencies
# See: https://www.gnu.org/software/make/manual/html_node/Automatic-Prerequisites.html
# Using following guide: 
# http://make.mad-scientist.net/papers/advanced-auto-dependency-generation/
DEPFLAGS = -MT $@ -MMD -MP -MF $(DEPENDDIR)/$*.d

WARNING_FLAGS = -Wall -Wshadow=local -Wextra -Wimplicit-fallthrough=1 \
		-Wno-unused-parameter 
		
CXXDEFINES = $(DEBUG_DEFINE) -D$(BOARD) -DAPI=FREE_RTOS_API
CDEFINES = -DUSE_HAL_DRIVER -DSTM32H743xx 

# Flags for c only
CFLAGS = $(CDEFINES)
# Flags for c++ only
CPPFLAGS = -std=c++17 -fno-exceptions 
# Flags for both
CXXFLAGS = $(MCU_FLAGS) $(DEBUG_LEVEL) $(OPTIMIZATION) -I. $(I_INCLUDES) -fmessage-length=0 \
		$(CXXDEFINES) $(WARNING_FLAGS) $(C_INCLUDES) $(DEPFLAGS)

# Object File Definitions
OBJ = $(CSRC:.c=.o) $(CXXSRC:.cpp=.o) $(ASRC:.s=.o)

# Define Messages
MSG_INFO = Software: Primary mission software for the STM32
MSG_LINKING = Linking:
MSG_COMPILING = Compiling:
MSG_ASSEMBLING = Assembling:
MSG_DEPENDENCY = Collecting dependencies for:
MSG_BINARY = Generate binary: 
MSG_OPTIMIZATION = Optimization: $(OPTIMIZATION), $(OPTIMIZATION_MESSAGE)
MSG_TARGET = Target Build: $(TARGET)
MSG_DEBUG = Debug level: $(DEBUG_LEVEL), FSFW Debugging: $(DEBUG_MESSAGE)

# including the dependency files
# make will rebuild included makefiles if it can.
# As we supplied a rule for the dependency files
# it will rebuild them before including them


# Flags for the linker call
# - specs=nosys.specs: this library contains system calls such as _sbrk(); 
#   without this library system calls are not enabled an functions like malloc
#   will not work	 
# - specs=nano.specs: links the reduced-size variant of the libc, called newlib-nano
# - LINK_INCLUDES: Specify the path to used libraries and the linker script
# - LINK_LIBRARIES: Link HCC and HAL library and enable float support

# LDFLAGS = -Wl,-L, $(DEBUG_LEVEL) $(MCU_FLAG) $(UNUSED_CODE_REMOVAL) $(OPTIMIZATION) \
		$(LINK_TIME_OPTIMIZATION) $(NEWLIB_NANO) 
LDFLAGS = -Wl,-L, $(DEBUG_LEVEL) $(MCU_FLAGS) $(UNUSED_CODE_REMOVAL) $(OPTIMIZATION) \
		$(LINK_TIME_OPTIMIZATION) $(NEWLIB_NANO) 
LINK_INCLUDES = -T"$(BSP_PATH)/linker.ld" \
		-Wl,-Map=$(BINDIR)/$(BINARY_NAME).map
LINK_LIBRARIES = -lc -lm

.PHONY: clean all
#-------------------------------------------------------------------------------
#		Rules
#-------------------------------------------------------------------------------
default: all

# building the binary
all: debug

clean:
	-rm -rf $(BUILDPATH)/$(BOARD)
	-rm -rf $(DEPENDPATH)/$(BOARD)
	-rm -rf $(OBJECTPATH)/$(BOARD)

hardclean:
	-rm -rf $(BUILDPATH)
	-rm -rf $(DEPENDPATH)
	-rm -rf $(OBJECTPATH)

debug virtual mission: executable

# Build target configuration, which also includes information output.
# See: https://www.gnu.org/software/make/manual/html_node/Target_002dspecific.html
# Link time optimization is added in the rules to disable it for certain source files
mission: OPTIMIZATION = -Os $(PROTOTYPE_OPTIMIZATION)
# Link time optimization can lead to issues, so  if there is an issue with the
# mission binary, try to disable it to see if that fixes the problem.
mission: LINK_TIME_OPTIMIZATION = -flto
mission: TARGET = Mission binary
mission: OPTIMIZATION_MESSAGE = On with Link Time Optimization.
mission: DEBUG_LEVEL = -g0

debug: CXXDEFINES += -DDEBUG
debug: DEBUG_MESSAGE = On
debug: DEBUG_LEVEL = -g3

executable: $(BINDIR)/$(BINARY_NAME).bin

# SHOW_DETAILS = 1

$(BINDIR)/$(BINARY_NAME).bin: $(BINDIR)/$(BINARY_NAME).elf
	@echo
	@echo $(MSG_INFO)
	@echo $(MSG_TARGET)
	@echo $(MSG_OPTIMIZATION)
	@echo $(MSG_DEBUG)
	@echo $(MSG_BINARY) $@
	@mkdir -p $(@D)
	$(BINCOPY) $< $@
ifeq ($(OS),Windows_NT)
	@echo Binary Size: `busybox stat -c %s $@` bytes
else
	@stat --printf='Binary Size: %s bytes' $@
endif
	@echo	

$(BINDIR)/$(BINARY_NAME).hex: $(BINDIR)/$(BINARY_NAME).elf
	$(HEXCOPY) $< $@

$(BINDIR)/$(BINARY_NAME).elf: $(addprefix $(OBJECTDIR)/, $(OBJ))
	@echo
	@echo $(MSG_LINKING) Target $@
	@mkdir -p $(@D)
ifdef SHOW_DETAILS
	$(CXX) $(LDFLAGS) $(LINK_INCLUDES) -o $@ $^ $(LINK_LIBRARIES)
else
	@$(CXX) $(LDFLAGS) $(LINK_INCLUDES) -o $@ $^ $(LINK_LIBRARIES)
endif
	@echo $@ was generated.

$(OBJECTDIR)/%.o : %.cpp
$(OBJECTDIR)/%.o : %.cpp $(DEPENDDIR)/%.d | $(DEPENDDIR) 
	@echo
	@echo $(MSG_COMPILING) $<
	@mkdir -p $(@D)
ifdef SHOW_DETAILS
	$(CXX) $(CXXFLAGS) $(CPPFLAGS) -c -o $@ $(<:.d=.cpp)
else
	@$(CXX) $(CXXFLAGS) $(CPPFLAGS) -c -o $@ $(<:.d=.cpp)
endif

$(OBJECTDIR)/%.o : %.c
$(OBJECTDIR)/%.o : %.c $(DEPENDDIR)/%.d | $(DEPENDDIR)
	@echo
	@echo $(MSG_COMPILING) $<
	@mkdir -p $(@D)
ifdef SHOW_DETAILS
	$(CC) $(CXXFLAGS) $(CFLAGS) -c -o $@ $(<:.d=.c)
else
	@$(CC) $(CXXFLAGS) $(CFLAGS) -c -o $@ $(<:.d=.c)
endif

$(OBJECTDIR)/%.o : %.s 
	@echo
	@echo $(MSG_ASSEMBLING) $<
	@mkdir -p $(@D)
ifdef SHOW_DETAILS
	$(AS) $(MCU_FLAGS) -c -o $@ $<
else
	@$(AS) $(MCU_FLAGS) -c -o $@ $<
endif

#-------------------------------------------------------------------------------
#		Dependency Handling
#-------------------------------------------------------------------------------

# Dependency Handling according to following guide:
# http://make.mad-scientist.net/papers/advanced-auto-dependency-generation/
$(DEPENDDIR):
	@mkdir -p $(@D)
DEPENDENCY_RELATIVE = $(CSRC:.c=.d) $(CXXSRC:.cpp=.d)
# This is the list of all dependencies
DEPFILES = $(addprefix $(DEPENDDIR)/, $(DEPENDENCY_RELATIVE))
# Create subdirectories for dependencies
$(DEPFILES):
	@mkdir -p $(@D)
# Include all dependencies
include $(wildcard $(DEPFILES))
